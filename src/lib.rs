#![cfg(not(doctest))]

use core::panic;

use proc_macro::TokenStream;
use quote::{quote, ToTokens};
use syn::{
    parse2, parse_str, Data, DataStruct, DeriveInput, Fields, GenericArgument, Ident,
    PathArguments, Type,
};

extern crate proc_macro;

/// Implements `From` trait for structs. This macro is designed to be used to
/// convert `graphql_client` library's autogenerated struct data into project's
/// struct.
///
/// It has `names` attribute on a struct level, which is a list of types that
/// will be converted. It is required.
///
/// It also has `from_name`, `recursive_into`, `skip` attributes on a field
/// level. `from_name` attribute is used to specify the name of the field in the
/// source struct, if the name of the field in the source struct is different
/// from the name of the field in the target struct. `recursive_into` attribute
/// is used to specify whether the field should be converted recursively by a
/// custom type's `From` implementation. `skip` attribute is used to specify
/// whether the field should be skipped. When more than one element is present
/// in the `names` attribute, each element will share the field level
/// attributes. All field level attributes are optional.
///
/// NOTE : this macro relies on lossy casting, `as _` when necessary, but this
/// is not an issue. It is because the integrity of data is solely upon the
/// project's struct, so data loss shall never happen. `graphql_client` library
/// and graphql's interpretes all number types as i64 at its code autogen, hence
/// it is necessary to force-cast.
///
/// LIMITATIONS : `graphql_client` library does not autogenerate tuple types as
/// response data. So for practical reason, this macro does not support tuple
/// types.
///
/// # Panics
/// Panics only occur in compile time, never in runtime. This macro panics when
/// inputs are incorrect. When you fail to use this macro, please run with -Z
/// macro-backtrace for more info. Since macro expansion occurs during
/// compilatione.
///
/// # Examples
/// ```no_run
/// use graphql_client::GraphQLQuery;
/// use async_graphql::SimpleObject;
///
/// #[derive(GraphQLQuery)]
/// #[graphql(
///     schema_path = "src/graphql/client/schema/schema.graphql",
///     query_path = "src/graphql/client/schema/conn_raw_events.graphql",
///     response_derives = "Clone, Default, PartialEq"
/// )]
/// pub struct ConnRawEvents;
///
/// #[derive(SimpleObject, ConvertGraphQLEdgesNode)]
/// #[graphql_client_type(names = [conn_raw_events::ConnRawEventsConnRawEventsEdgesNode, network_raw_events::NetworkRawEventsNetworkRawEventsEdgesNodeOnConnRawEvent])]
/// struct ConnRawEvent {
///     timestamp: DateTime,
///     orig_port: Option<u16>,
///     proto: u8,
///     duration: i64,
///     service: String,
///     resp_pkts: u64,
///     ttl: Vec<i32>,
///     orig_filenames: Vec<String>,
///     #[graphql_client_type(from_name = "ja3_s")]
///     ja3s: String,
///     #[graphql_client_type(skip = true)]
///     some_field: String,
///     #[graphql_client_type(recursive_into = true)]
///     details: Vec<ConnRawEventDetail>,
/// }
///
/// #[graphql_client_type(names = [conn_raw_events::ConnRawEventsConnRawEventsEdgesNodeDetails, network_raw_events::NetworkRawEventsNetworkRawEventsEdgesNodeOnConnRawEventDetails])]
/// pub struct ConnRawEventDetail {
///     pub protocol: String,
///     pub pps: Option<f64>,
///     #[graphql_client_type(recursive_into = true)]
///     pub link: Vec<ConnRawEventHelpLink>,
/// }
///
/// #[graphql_client_type(names = [conn_raw_events::ConnRawEventsConnRawEventsEdgesNodeDetailsLink, network_raw_events::NetworkRawEventsNetworkRawEventsEdgesNodeOnConnRawEventDetailsLink])]
/// pub struct ConnRawEventHelpLink {
///     pub url: String,
/// }
///```
///
/// Above code expands to below.
/// ```no_run
/// impl From<conn_raw_events::ConnRawEventsConnRawEventsEdgesNode> for ConnRawEvent {
///     fn from(node: conn_raw_events::ConnRawEventsConnRawEventsEdgesNode) -> Self {
///         Self {
///             timestamp: node.timestamp,
///             #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
///             orig_port: node.orig_port.map(|x| x as _),
///             #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
///             proto: node.proto as _,
///             #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
///             duration: node.duration as __,
///             #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
///             service: node.service as _,
///             #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
///             resp_pkts: node.resp_pkts as _,
///             #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
///             ttl: node.ttl.into_iter().map(|x| x as _).collect(),
///             orig_filenames: node.orig_filenames,
///             ja3s: node.ja3_s,
///             details: node.details.into_iter().map(|x| x.into()).collect(),
///         }
///     }
/// }
///
/// impl From<network_raw_events::NetworkRawEventsNetworkRawEventsEdgesNodeOnConnRawEvent> for ConnRawEvent {
///     fn from(node: network_raw_events::NetworkRawEventsNetworkRawEventsEdgesNodeOnConnRawEvent) -> Self {
///         Self {
///             timestamp: node.timestamp,
///             #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
///             orig_port: node.orig_port.map(|x| x as _),
///             #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
///             proto: node.proto as _,
///             #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
///             duration: node.duration as __,
///             #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
///             service: node.service as _,
///             #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
///             resp_pkts: node.resp_pkts as _,
///             #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
///             ttl: node.ttl.into_iter().map(|x| x as _).collect(),
///             orig_filenames: node.orig_filenames,
///             ja3s: node.ja3_s,
///             details: node.details.into_iter().map(|x| x.into()).collect(),
///         }
///     }
/// }
///
/// impl From<conn_raw_events::ConnRawEventsConnRawEventsEdgesNodeDetails> for ConnRawEventDetail {
///     fn from(node: conn_raw_events::ConnRawEventsConnRawEventsEdgesNodeDetails) -> Self {
///         Self {
///             protocol: node.protocol,
///             pps: node.pps,
///             link: node.link.into_iter().map(|x| x.into()).collect(),
///         }
///     }
/// }
///
/// impl From<network_raw_events::NetworkRawEventsNetworkRawEventsEdgesNodeOnConnRawEventDetails> for ConnRawEventDetail {
///     fn from(node: network_raw_events::NetworkRawEventsNetworkRawEventsEdgesNodeOnConnRawEventDetails) -> Self {
///         Self {
///             protocol: node.protocol,
///             pps: node.pps,
///             link: node.link.into_iter().map(|x| x.into()).collect(),
///         }
///     }
/// }
///
/// impl From<conn_raw_events::ConnRawEventsConnRawEventsEdgesNodeDetailsLink> for ConnRawEventHelpLink {
///     fn from(node: conn_raw_events::ConnRawEventsConnRawEventsEdgesNodeDetailsLink) -> Self {
///         Self {
///             url: node.url,
///         }
///     }
/// }
///
/// impl From<network_raw_events::NetworkRawEventsNetworkRawEventsEdgesNodeOnConnRawEventDetailsLink> for ConnRawEventHelpLink {
///     fn from(node: network_raw_events::NetworkRawEventsNetworkRawEventsEdgesNodeOnConnRawEventDetailsLink) -> Self {
///         Self {
///             url: node.url,
///         }
///     }
/// }
///
/// ```
#[proc_macro_derive(ConvertGraphQLEdgesNode, attributes(graphql_client_type))]
pub fn derive_from_graphql_client_autogen(input: TokenStream) -> TokenStream {
    derive_from_graphql_client_autogen_2(input.into())
        .unwrap()
        .into()
}

#[derive(deluxe::ExtractAttributes)]
#[deluxe(attributes(graphql_client_type))]
struct FromGraphQlAutogenStructAttrs {
    names: Vec<Type>,
}

#[derive(deluxe::ExtractAttributes, deluxe::ParseAttributes)]
#[deluxe(attributes(graphql_client_type))]
struct GraphQlAutogenFieldAttrs {
    #[deluxe(default = String::new())]
    pub from_name: String,
    #[deluxe(default = false)]
    pub recursive_into: bool,
    #[deluxe(default = false)]
    pub skip: bool,
}

fn derive_from_graphql_client_autogen_2(
    item: proc_macro2::TokenStream,
) -> deluxe::Result<proc_macro2::TokenStream> {
    let mut ast: DeriveInput = parse2(item)?;

    let FromGraphQlAutogenStructAttrs { names } = deluxe::extract_attributes(&mut ast)?;

    let struct_ident = &ast.ident;

    if let Data::Struct(DataStruct { fields, .. }) = &ast.data {
        let implementations = names.into_iter().map(|name| {
            let field_conversions = match fields {
                Fields::Named(named_fields) => named_fields.named.iter().map(|field| {
                    let GraphQlAutogenFieldAttrs { from_name, recursive_into, skip } = deluxe::parse_attributes(field).unwrap_or_else(|_| panic!("inappropriate use of field attributes on {}. Allowed field attributes are `from_name: String`, `recursive_into: bool`, `skip: bool`. Found {:?}", field.to_token_stream().to_string(), field.attrs.iter().map(|attr| attr.into_token_stream().to_string()).collect::<Vec<_>>()));

                    if skip {
                        return quote! {};
                    }

                    let to_field_name = &field.ident.clone().unwrap_or_else(|| panic!("inappropriate field {}. Please make sure the field is named", field.to_token_stream().to_string()));
                    let from_field_name = resolve_from_field_name(&from_name, to_field_name);
                    let field_type = &field.ty;

                    match segment_type_and_cast_style(field_type, recursive_into) {
                        (_, CastStyle::None) => {
                            quote! {
                                #to_field_name: node.#from_field_name,
                            }
                        },
                        (SegmentType::Vec, CastStyle::As) => {
                            quote! {
                                #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
                                #to_field_name: node.#from_field_name.into_iter().map(|x| x as _).collect(),
                            }
                        },
                        (SegmentType::Option, CastStyle::As) => {
                            quote! {
                                #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
                                #to_field_name: node.#from_field_name.map(|x| x as _),
                            }
                        },
                        (SegmentType::Other, CastStyle::As) => {
                            quote! {
                                #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
                                #to_field_name: node.#from_field_name as _,
                            }
                        },
                        (SegmentType::Vec, CastStyle::Into) => {
                            quote! {
                                #to_field_name: node.#from_field_name.into_iter().map(|x| x.into()).collect(),
                            }
                        },
                        (SegmentType::Option, CastStyle::Into) => {
                            quote! {
                                #to_field_name: node.#from_field_name.map(|x| x.into()),
                            }
                        },
                        (SegmentType::Other,CastStyle::Into) => {
                            quote! {
                                #to_field_name: node.#from_field_name.into(),
                            }
                        },
                    }
                }),
                _ => {
                    panic!(
                        "Structs that derive `ConvertGraphQLEdgesNode` should only have named fields"
                    );
                }
            };

            quote! {
                impl From<#name> for #struct_ident {
                    fn from(node: #name) -> Self {
                        Self {
                            #( #field_conversions )*
                        }
                    }
                }
            }
        }).collect::<Vec<_>>();

        Ok(quote! {
            #(#implementations)*
        })
    } else {
        let implementations = names
            .iter()
            .map(|name| {
                quote! {
                    impl From<#name> for #struct_ident {
                        fn from(node: #name) -> Self {
                            Self {}
                        }
                    }
                }
            })
            .collect::<Vec<_>>();

        Ok(quote! {
            #(#implementations)*
        })
    }
}

fn resolve_from_field_name(from_name: &str, field_name: &Ident) -> Ident {
    if from_name.is_empty() {
        field_name.clone()
    } else {
        parse_str::<Ident>(from_name).unwrap_or_else(|_| panic!(r#"inappropriate use of `from_name`. Please check if the value of `from_name = "{from_name}"` exists in the specified source structs in `names` attribute"#))
    }
}

#[derive(PartialEq)]
enum SegmentType {
    Other,
    Vec,
    Option,
}

#[derive(PartialEq)]
enum CastStyle {
    None,
    As,
    Into,
}

fn segment_type_and_cast_style(ty: &Type, recursive_into: bool) -> (SegmentType, CastStyle) {
    if let Type::Path(type_path) = ty {
        if let Some(segment) = type_path.path.segments.last() {
            if segment.ident == "Vec" {
                if let PathArguments::AngleBracketed(vec_element_type_arg) = &segment.arguments {
                    for arg in &vec_element_type_arg.args {
                        match arg {
                            GenericArgument::Type(el_type) => {
                                return (SegmentType::Vec, cast_style(el_type, recursive_into));
                            }
                            _ => continue,
                        }
                    }
                }
            } else if segment.ident == "Option" {
                if let PathArguments::AngleBracketed(option_element_type_arg) = &segment.arguments {
                    for arg in &option_element_type_arg.args {
                        match arg {
                            GenericArgument::Type(el_type) => {
                                return (SegmentType::Option, cast_style(el_type, recursive_into));
                            }
                            _ => continue,
                        }
                    }
                }
            } else {
                return (SegmentType::Other, cast_style(ty, recursive_into));
            }
        }
    }
    (SegmentType::Other, cast_style(ty, recursive_into))
}

fn cast_style(field_type: &Type, recursive_into: bool) -> CastStyle {
    if is_target_of_force_cast(field_type) {
        assert!(!recursive_into, "inappropriate use of `recursive_into`. Please remove `recursive_into` attribute on a field with `{}`", field_type.to_token_stream());
        CastStyle::As
    } else if recursive_into {
        CastStyle::Into
    } else {
        CastStyle::None
    }
}

static TARGET_OF_FORCE_CAST: [&str; 8] = ["u8", "u16", "i8", "i16", "i32", "u32", "u64", "usize"];

fn is_target_of_force_cast(ty: &Type) -> bool {
    let type_token = ty.to_token_stream().to_string();
    TARGET_OF_FORCE_CAST.contains(&type_token.as_str())
}
