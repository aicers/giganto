#![cfg(not(doctest))]

use proc_macro::TokenStream;
use quote::{quote, ToTokens};
use syn::{
    parse2, parse_str, Data, DataStruct, DeriveInput, Fields, GenericArgument, Ident,
    PathArguments, Type,
};

extern crate proc_macro;

/// Implements `From` trait for structs. This macro is designed to be used to
/// convert `graphql_client` library's autogenerated struct data into project's
/// struct.
///
/// NOTE : this macro relies on lossy casting, `as _`, but this is not an issue.
/// It is because the integrity of data is solely upon the project's struct, so
/// data loss shall never happen. `graphql_client` library and graphql's
/// interpretes all number types as i64 at its code autogen, hence it is
/// necessary to force-cast.
///
/// LIMITATIONS : `graphql_client` library does not autogenerate tuple types as
/// response data. So for practical reason, this macro does not support tuple
/// types.
///
/// # Panics
/// This macro panics when inputs are incorrect. When you fail to use this
/// macro, please run with -Z macro-backtrace for more info. Since macro
/// expansion occurs during compilation, panics from this macro will never occur
/// in runtime, but only in compile time.
///
/// # Examples
/// ```no_run
/// use graphql_client::GraphQLQuery;
/// use async_graphql::SimpleObject;
///
/// #[derive(GraphQLQuery)]
/// #[graphql(
///     schema_path = "src/graphql/client/schema/schema.graphql",
///     query_path = "src/graphql/client/schema/conn_raw_events.graphql",
///     response_derives = "Clone, Default, PartialEq"
/// )]
/// pub struct ConnRawEvents;
///
/// #[derive(SimpleObject, ConvertGraphQLEdgesNode)]
/// #[graphql_client_type(name = conn_raw_events::ConnRawEventsConnRawEventsEdgesNode)]
/// struct ConnRawEvent {
///     timestamp: DateTime,
///     orig_port: u16,
///     proto: u8,
///     duration: i64,
///     service: String,
///     resp_pkts: u64,
///     ttl: Vec<i32>,
///     orig_filenames: Vec<String>,
///     #[graphql_client_type(from_name = "ja3_s")]
///     ja3s: String,
///     #[graphql_client_type(skip = true)]
///     some_field: String,
/// }
///```
///
/// Above code expands to below.
/// ```no_run
/// impl From<conn_raw_events::ConnRawEventsConnRawEventsEdgesNode> for ConnRawEvent {
///     #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
///     fn from(node: conn_raw_events::ConnRawEventsConnRawEventsEdgesNode) -> Self {
///         Self {
///             timestamp: node.timestamp,
///             orig_port: node.orig_port ,
///             proto: node.proto as _,,
///             duration: node.duration as __,
///             service: node.service as _,
///             resp_pkts: node.resp_pkts as _,
///             ttl: node.ttl.into_iter().map(|x| x as _).collect(),
///             orig_filenames: node.orig_filenames,
///             ja3s: node.ja3_s,
///         }
///     }
/// }
/// ```
#[proc_macro_derive(ConvertGraphQLEdgesNode, attributes(graphql_client_type))]
pub fn derive_from_graphql_client_autogen(input: TokenStream) -> TokenStream {
    derive_from_graphql_client_autogen_2(input.into())
        .unwrap()
        .into()
}

#[derive(deluxe::ExtractAttributes)]
#[deluxe(attributes(graphql_client_type))]
struct FromGraphQlAutogenStructAttrs {
    name: Type,
}

#[derive(deluxe::ExtractAttributes)]
#[deluxe(attributes(graphql_client_type))]
struct GraphQlAutogenFieldAttrs {
    #[deluxe(default = String::new())]
    pub from_name: String,
    #[deluxe(default = false)]
    pub skip: bool,
}

fn derive_from_graphql_client_autogen_2(
    item: proc_macro2::TokenStream,
) -> deluxe::Result<proc_macro2::TokenStream> {
    let mut ast: DeriveInput = parse2(item)?;

    let FromGraphQlAutogenStructAttrs { name } = deluxe::extract_attributes(&mut ast)?;
    let struct_ident = &ast.ident;

    if let Data::Struct(DataStruct { fields, .. }) = &mut ast.data {
        let field_conversions = match fields {
            Fields::Named(named_fields) => named_fields.named.iter_mut().map(|field| {
                let GraphQlAutogenFieldAttrs { from_name, skip } =
                    deluxe::extract_attributes(field).unwrap(); // This unwrap occurs only in compile time.
                if skip {
                    return quote! {};
                }
                let to_field_name = &field.ident.clone().unwrap();
                let from_field_name = resolve_from_field_name(&from_name, to_field_name);
                let field_type = &field.ty;
                if is_map_cast_needed(field_type) {
                    quote! {
                        #to_field_name: node.#from_field_name.into_iter().map(|x| x as _).collect(),
                    }
                } else if is_target_of_force_cast(field_type) {
                    quote! {
                        #to_field_name: node.#from_field_name as _,
                    }
                } else {
                    quote! {
                        #to_field_name: node.#from_field_name,
                    }
                }
            }),
            _ => {
                panic!(
                    "Structs that derive `ConvertGraphQLEdgesNode` should only have named fields"
                );
            }
        };

        let suppress_clippy_warning =
            quote! { #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)] };
        Ok(quote! {
            impl From<#name> for #struct_ident {
                #suppress_clippy_warning
                fn from(node: #name) -> Self {
                    Self {
                        #( #field_conversions )*
                    }
                }
            }
        })
    } else {
        Ok(quote! {
            impl From<#name> for #struct_ident {
                fn from(node: #name) -> Self {
                    Self {}
                }
            }
        })
    }
}

fn resolve_from_field_name(from_name: &str, field_name: &Ident) -> Ident {
    if from_name.is_empty() {
        field_name.clone()
    } else {
        parse_str::<Ident>(from_name).unwrap()
    }
}

fn is_map_cast_needed(ty: &Type) -> bool {
    if let Type::Path(type_path) = ty {
        if let Some(segment) = type_path.path.segments.last() {
            if segment.ident == "Vec" {
                if let PathArguments::AngleBracketed(vec_element_type_arg) = &segment.arguments {
                    for arg in &vec_element_type_arg.args {
                        match arg {
                            GenericArgument::Type(vec_el_type) => {
                                return is_target_of_force_cast(vec_el_type);
                            }
                            _ => continue,
                        }
                    }
                }
            } else {
                return false;
            }
        }
    }
    false
}

// TODO: https://github.com/aicers/review-web/issues/37 이슈 fix 시 "u32", "u64", "usize" 제거 필요
static TARGET_OF_FORCE_CAST: [&str; 8] = ["u8", "u16", "i8", "i16", "i32", "u32", "u64", "usize"];

fn is_target_of_force_cast(ty: &Type) -> bool {
    let type_token = ty.to_token_stream().to_string();
    TARGET_OF_FORCE_CAST.contains(&type_token.as_str())
}
